{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport axios from 'axios';\n\n// CSRF 토큰을 가져와 Axios 인스턴스에 추가\nconst getCsrfToken = async () => {\n  try {\n    const response = await axios.get('https://d5bf569728f0.ngrok.app/odsay/set-csrf-token/', {\n      withCredentials: true\n    });\n    console.log('MapView.js >> CSRF token received:', response.data);\n    return response.data.csrfToken;\n  } catch (error) {\n    console.error('MapView.js >> Error fetching CSRF token:', error);\n    throw error; // 에러 발생 시 throw로 전달\n  }\n};\n\n// // ODSAY API 키\n// const ODSAY_API_KEY = process.env.VUE_APP_ODSAY_API_KEY;\n\n// Axios 인스턴스 생성 및 기본 설정 추가\nconst axiosInstance = axios.create({\n  baseURL: 'https://d5bf569728f0.ngrok.app',\n  // ngrok 도메인 설정\n  withCredentials: true // 자격 증명 포함\n});\naxiosInstance.interceptors.request.use(async config => {\n  try {\n    const token = await getCsrfToken();\n    config.headers['X-CSRFToken'] = token;\n    console.log('MapView.js >> CSRF token set in request headers:', token);\n    return config;\n  } catch (error) {\n    console.error('MapView.js >> Failed to set CSRF token in request headers:', error);\n    return Promise.reject(error); // 에러 발생 시 요청 중단\n  }\n});\nexport default {\n  props: {\n    memHome: String,\n    startPoint: String,\n    endPoint: String,\n    memYoungY: Boolean,\n    memYoungN: Boolean,\n    memSubsidiaryYn: Boolean\n  },\n  data() {\n    return {\n      localStartPoint: this.startPoint,\n      localEndPoint: this.endPoint,\n      routes: []\n    };\n  },\n  methods: {\n    async geocode(address) {\n      try {\n        console.log('MapView.js >> Geocoding address:', address);\n        const response = await axiosInstance.get('/odsay/geocode/', {\n          params: {\n            address\n          }\n        });\n        console.log('MapView.js >> Geocode response:', response.data);\n        return response.data;\n      } catch (error) {\n        console.error('MapView.js >> Error geocoding address:', error);\n        if (error.response) {\n          console.error('MapView.js >> Error response data:', error.response.data);\n        }\n        throw error;\n      }\n    },\n    async findRoute() {\n      try {\n        console.log('MapView.js >> Finding route with start point:', this.localStartPoint, 'and end point:', this.localEndPoint);\n\n        // Geocoding 주소를 통해 좌표를 가져오는 부분 (백엔드에서 처리)\n        const startResponse = await this.geocode(this.localStartPoint); // GET 메서드를 사용하도록 수정\n        console.log('MapView.js >> Start geocode response:', startResponse);\n        const endResponse = await this.geocode(this.localEndPoint); // GET 메서드를 사용하도록 수정\n        console.log('MapView.js >> End geocode response:', endResponse);\n        if (!startResponse || !endResponse) {\n          throw new Error('Failed to get coordinates');\n        }\n\n        // startResponse와 endResponse에서 올바르게 데이터를 추출\n        const sx = startResponse.x;\n        const sy = startResponse.y;\n        const ex = endResponse.x;\n        const ey = endResponse.y;\n        console.log('MapView.js >> Start coordinates:', {\n          sx,\n          sy\n        });\n        console.log('MapView.js >> End coordinates:', {\n          ex,\n          ey\n        });\n\n        // ODSAY API를 통해 경로 찾기 요청\n        const odsasApiUrl = `searchPubTransPathT?SX=${sx}&SY=${sy}&EX=${ex}&EY=${ey}&apiKey=${encodeURIComponent(process.env.VUE_APP_ODSAY_API_KEY)}`;\n        console.log('MapView.js >> ODSAY API request URL:', odsasApiUrl); // 요청 URL을 로그에 출력\n\n        const routeResponse = await this.$odsayAxios.get(odsasApiUrl);\n        console.log('MapView.js >> ODSAY API response:', routeResponse.data);\n        if (routeResponse.data && routeResponse.data.result && routeResponse.data.result.path) {\n          this.routes = routeResponse.data.result.path.map(path => {\n            return {\n              totalTime: path.info.totalTime,\n              totalWalk: path.info.totalWalk,\n              busTransitCount: path.info.busTransitCount,\n              subwayTransitCount: path.info.subwayTransitCount,\n              payment: path.info.payment,\n              totalDistance: path.info.totalDistance,\n              firstStartStation: path.subPath[0].startName,\n              startNameKor: path.subPath[0].startName,\n              endName: path.subPath[path.subPath.length - 1].endName,\n              lastEndStation: path.subPath[path.subPath.length - 1].endName,\n              subPaths: path.subPath\n            };\n          });\n        }\n      } catch (error) {\n        console.error('MapView.js >> Error finding route:', error);\n      }\n    },\n    async displayRoute(mapObj) {\n      try {\n        const apiKey = process.env.VUE_APP_ODSAY_API_KEY;\n        const url = `loadLane?mapObject=0:0@${mapObj}&apiKey=${encodeURIComponent(apiKey)}`;\n        const response = await axios.get(url);\n        if (response.status === 200) {\n          const resultJsonData = response.data;\n          this.drawNaverMarker(this.sx, this.sy); // 출발지 마커 표시\n          this.drawNaverMarker(this.ex, this.ey); // 도착지 마커 표시\n          this.drawNaverPolyLine(resultJsonData); // 노선 그래픽 데이터 지도 위 표시\n          if (resultJsonData.result.boundary) {\n            const boundary = new naver.maps.LatLngBounds(new naver.maps.LatLng(resultJsonData.result.boundary.top, resultJsonData.result.boundary.left), new naver.maps.LatLng(resultJsonData.result.boundary.bottom, resultJsonData.result.boundary.right));\n            this.map.panToBounds(boundary);\n          }\n        }\n      } catch (error) {\n        console.error('MapView.js >> Error displaying route:', error);\n      }\n    },\n    formatTime(minutes) {\n      const hours = Math.floor(minutes / 60);\n      const mins = minutes % 60;\n      return `${hours}시간 ${mins}분`;\n    },\n    getLineClass(trafficType, subwaycode) {\n      if (trafficType === 1) {\n        return 'bus';\n      } else if (trafficType === 2) {\n        return `sub${subwaycode}`;\n      } else {\n        return 'walk';\n      }\n    },\n    getAction(subPath, startName, lane) {\n      if (subPath.trafficType === 1) {\n        return `지하철 ${lane.map(l => l.name).join(', ')} - ${startName}역`;\n      } else if (subPath.trafficType === 2) {\n        return `버스 ${lane.map(l => l.busNo).join(', ')} 번 - ${startName}`;\n      } else {\n        return `도보 - ${startName}`;\n      }\n    },\n    initializeMap() {\n      if (window.naver) {\n        var mapOptions = {\n          center: new naver.maps.LatLng(37.5665, 126.9780),\n          zoom: 10\n        };\n        this.map = new naver.maps.Map('map', mapOptions);\n      } else {\n        console.error('MapView.js >> Naver Maps API is not loaded.');\n      }\n    },\n    drawNaverMarker(x, y) {\n      new naver.maps.Marker({\n        position: new naver.maps.LatLng(y, x),\n        map: this.map\n      });\n    },\n    drawNaverPolyLine(data) {\n      let lineArray;\n      for (let i = 0; i < data.result.lane.length; i++) {\n        for (let j = 0; j < data.result.lane[i].section.length; j++) {\n          lineArray = [];\n          for (let k = 0; k < data.result.lane[i].section[j].graphPos.length; k++) {\n            lineArray.push(new naver.maps.LatLng(data.result.lane[i].section[j].graphPos[k].y, data.result.lane[i].section[j].graphPos[k].x));\n          }\n          // 지하철 결과의 경우 노선에 따른 라인 색상 지정하는 부분\n          new naver.maps.Polyline({\n            map: this.map,\n            path: lineArray,\n            strokeWeight: 3,\n            strokeColor: data.result.lane[i].type === 1 ? '#003499' : data.result.lane[i].type === 2 ? '#37b42d' : '#000'\n          });\n        }\n      }\n    }\n  },\n  async mounted() {\n    this.initializeMap();\n  }\n};","map":{"version":3,"names":["axios","getCsrfToken","response","get","withCredentials","console","log","data","csrfToken","error","axiosInstance","create","baseURL","interceptors","request","use","config","token","headers","Promise","reject","props","memHome","String","startPoint","endPoint","memYoungY","Boolean","memYoungN","memSubsidiaryYn","localStartPoint","localEndPoint","routes","methods","geocode","address","params","findRoute","startResponse","endResponse","Error","sx","x","sy","y","ex","ey","odsasApiUrl","encodeURIComponent","process","env","VUE_APP_ODSAY_API_KEY","routeResponse","$odsayAxios","result","path","map","totalTime","info","totalWalk","busTransitCount","subwayTransitCount","payment","totalDistance","firstStartStation","subPath","startName","startNameKor","endName","length","lastEndStation","subPaths","displayRoute","mapObj","apiKey","url","status","resultJsonData","drawNaverMarker","drawNaverPolyLine","boundary","naver","maps","LatLngBounds","LatLng","top","left","bottom","right","panToBounds","formatTime","minutes","hours","Math","floor","mins","getLineClass","trafficType","subwaycode","getAction","lane","l","name","join","busNo","initializeMap","window","mapOptions","center","zoom","Map","Marker","position","lineArray","i","j","section","k","graphPos","push","Polyline","strokeWeight","strokeColor","type","mounted"],"sources":["/Users/parkjiyoung/Desktop/computer/smart_injae/hackshim_project/saveus_proto/saveus/frontend/src/assets/js/MapView.js"],"sourcesContent":["import axios from 'axios';\n\n// CSRF 토큰을 가져와 Axios 인스턴스에 추가\nconst getCsrfToken = async () => {\n    try {\n        const response = await axios.get('https://d5bf569728f0.ngrok.app/odsay/set-csrf-token/', { withCredentials: true });\n        console.log('MapView.js >> CSRF token received:', response.data);\n        return response.data.csrfToken;\n    } catch (error) {\n        console.error('MapView.js >> Error fetching CSRF token:', error);\n        throw error;  // 에러 발생 시 throw로 전달\n    }\n};\n\n// // ODSAY API 키\n// const ODSAY_API_KEY = process.env.VUE_APP_ODSAY_API_KEY;\n\n// Axios 인스턴스 생성 및 기본 설정 추가\nconst axiosInstance = axios.create({\n    baseURL: 'https://d5bf569728f0.ngrok.app',  // ngrok 도메인 설정\n    withCredentials: true  // 자격 증명 포함\n});\n\naxiosInstance.interceptors.request.use(async (config) => {\n    try {\n        const token = await getCsrfToken();\n        config.headers['X-CSRFToken'] = token;\n        console.log('MapView.js >> CSRF token set in request headers:', token);\n        return config;\n    } catch (error) {\n        console.error('MapView.js >> Failed to set CSRF token in request headers:', error);\n        return Promise.reject(error);  // 에러 발생 시 요청 중단\n    }\n});\n\n\nexport default {\n    props: {\n        memHome: String,\n        startPoint: String,\n        endPoint: String,\n        memYoungY: Boolean,\n        memYoungN: Boolean,\n        memSubsidiaryYn: Boolean\n    },\n    data() {\n        return {\n            localStartPoint: this.startPoint,\n            localEndPoint: this.endPoint,\n            routes: []\n        };\n    },\n    methods: {\n        async geocode(address) {\n            try {\n                console.log('MapView.js >> Geocoding address:', address);\n                const response = await axiosInstance.get('/odsay/geocode/', { params: { address } });\n                console.log('MapView.js >> Geocode response:', response.data);\n                return response.data;\n            } catch (error) {\n                console.error('MapView.js >> Error geocoding address:', error);\n                if (error.response) {\n                    console.error('MapView.js >> Error response data:', error.response.data);\n                }\n                throw error;\n            }\n        },\n        \n        async findRoute() {\n            try {\n                console.log('MapView.js >> Finding route with start point:', this.localStartPoint, 'and end point:', this.localEndPoint);\n                \n                 // Geocoding 주소를 통해 좌표를 가져오는 부분 (백엔드에서 처리)\n                const startResponse = await this.geocode(this.localStartPoint);  // GET 메서드를 사용하도록 수정\n                console.log('MapView.js >> Start geocode response:', startResponse);\n                const endResponse = await this.geocode(this.localEndPoint);  // GET 메서드를 사용하도록 수정\n                console.log('MapView.js >> End geocode response:', endResponse);\n                \n                if (!startResponse || !endResponse) {\n                    throw new Error('Failed to get coordinates');\n                }\n\n                // startResponse와 endResponse에서 올바르게 데이터를 추출\n                const sx = startResponse.x;\n                const sy = startResponse.y;\n                const ex = endResponse.x;\n                const ey = endResponse.y;\n                \n                console.log('MapView.js >> Start coordinates:', { sx, sy });\n                console.log('MapView.js >> End coordinates:', { ex, ey });\n                \n                // ODSAY API를 통해 경로 찾기 요청\n                const odsasApiUrl = `searchPubTransPathT?SX=${sx}&SY=${sy}&EX=${ex}&EY=${ey}&apiKey=${encodeURIComponent(process.env.VUE_APP_ODSAY_API_KEY)}`;\n                console.log('MapView.js >> ODSAY API request URL:', odsasApiUrl); // 요청 URL을 로그에 출력\n                \n                const routeResponse = await this.$odsayAxios.get(odsasApiUrl);\n                console.log('MapView.js >> ODSAY API response:', routeResponse.data);\n\n                if (routeResponse.data && routeResponse.data.result && routeResponse.data.result.path) {\n                    this.routes = routeResponse.data.result.path.map((path) => {\n                        return {\n                            totalTime: path.info.totalTime,\n                            totalWalk: path.info.totalWalk,\n                            busTransitCount: path.info.busTransitCount,\n                            subwayTransitCount: path.info.subwayTransitCount,\n                            payment: path.info.payment,\n                            totalDistance: path.info.totalDistance,\n                            firstStartStation: path.subPath[0].startName,\n                            startNameKor: path.subPath[0].startName,\n                            endName: path.subPath[path.subPath.length - 1].endName,\n                            lastEndStation: path.subPath[path.subPath.length - 1].endName,\n                            subPaths: path.subPath,\n                        };\n                    });\n                }\n            } catch (error) {\n                console.error('MapView.js >> Error finding route:', error);\n            }\n        },\n\n        async displayRoute(mapObj) {\n            try {\n                const apiKey = process.env.VUE_APP_ODSAY_API_KEY;\n                const url = `loadLane?mapObject=0:0@${mapObj}&apiKey=${encodeURIComponent(apiKey)}`;\n                const response = await axios.get(url);\n                if (response.status === 200) {\n                    const resultJsonData = response.data;\n                    this.drawNaverMarker(this.sx, this.sy);  // 출발지 마커 표시\n                    this.drawNaverMarker(this.ex, this.ey);  // 도착지 마커 표시\n                    this.drawNaverPolyLine(resultJsonData);  // 노선 그래픽 데이터 지도 위 표시\n                    if (resultJsonData.result.boundary) {\n                        const boundary = new naver.maps.LatLngBounds(\n                            new naver.maps.LatLng(resultJsonData.result.boundary.top, resultJsonData.result.boundary.left),\n                            new naver.maps.LatLng(resultJsonData.result.boundary.bottom, resultJsonData.result.boundary.right)\n                        );\n                        this.map.panToBounds(boundary);\n                    }\n                }\n            } catch (error) {\n                console.error('MapView.js >> Error displaying route:', error);\n            }\n        },\n\n        formatTime(minutes) {\n            const hours = Math.floor(minutes / 60);\n            const mins = minutes % 60;\n            return `${hours}시간 ${mins}분`;\n        },\n\n        getLineClass(trafficType, subwaycode) {\n            if (trafficType === 1) {\n                return 'bus';\n            } else if (trafficType === 2) {\n                return `sub${subwaycode}`;\n            } else {\n                return 'walk';\n            }\n        },\n\n        getAction(subPath, startName, lane) {\n            if (subPath.trafficType === 1) {\n                return `지하철 ${lane.map(l => l.name).join(', ')} - ${startName}역`;\n            } else if (subPath.trafficType === 2) {\n                return `버스 ${lane.map(l => l.busNo).join(', ')} 번 - ${startName}`;\n            } else {\n                return `도보 - ${startName}`;\n            }\n        },\n\n        initializeMap() {\n            if (window.naver) {\n                var mapOptions = {\n                    center: new naver.maps.LatLng(37.5665, 126.9780),\n                    zoom: 10\n                };\n                this.map = new naver.maps.Map('map', mapOptions);\n            } else {\n                console.error('MapView.js >> Naver Maps API is not loaded.');\n            }\n        },\n\n        drawNaverMarker(x, y) {\n            new naver.maps.Marker({\n                position: new naver.maps.LatLng(y, x),\n                map: this.map\n            });\n        },\n\n        drawNaverPolyLine(data) {\n            let lineArray;\n            for (let i = 0; i < data.result.lane.length; i++) {\n                for (let j = 0; j < data.result.lane[i].section.length; j++) {\n                    lineArray = [];\n                    for (let k = 0; k < data.result.lane[i].section[j].graphPos.length; k++) {\n                        lineArray.push(new naver.maps.LatLng(data.result.lane[i].section[j].graphPos[k].y, data.result.lane[i].section[j].graphPos[k].x));\n                    }\n                    // 지하철 결과의 경우 노선에 따른 라인 색상 지정하는 부분\n                    new naver.maps.Polyline({\n                        map: this.map,\n                        path: lineArray,\n                        strokeWeight: 3,\n                        strokeColor: data.result.lane[i].type === 1 ? '#003499' : data.result.lane[i].type === 2 ? '#37b42d' : '#000'\n                    });\n                }\n            }\n        }\n    },\n    async mounted() {\n        this.initializeMap();\n    },\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}